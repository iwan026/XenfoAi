import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Union
from datetime import datetime, timezone, timedelta
from config import TradingConfig

logger = logging.getLogger(__name__)


class SignalUtils:
    """Utility class for signal management and analysis"""

    @staticmethod
    def setup_logging(log_level: int = logging.INFO) -> None:
        """Setup centralized logging configuration"""
        try:
            log_file = (
                TradingConfig.LOG_DIR
                / f"signal_bot_{datetime.now(timezone.utc).strftime('%Y%m%d')}.log"
            )

            logging.basicConfig(
                level=log_level,
                format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                handlers=[logging.StreamHandler(), logging.FileHandler(log_file)],
            )
            logger.info(f"Logging initialized - Log file: {log_file}")

        except Exception as e:
            print(f"Error setting up logging: {str(e)}")

    @staticmethod
    def format_signal_message(signal_data: Dict) -> str:
        """Format signal data into a readable Telegram message"""
        try:
            # Signal type emoji mapping
            SIGNAL_EMOJIS = {"BUY": "ðŸŸ¢", "SELL": "ðŸ”´", "HOLD": "âšª"}

            emoji = SIGNAL_EMOJIS.get(signal_data["signal"], "âšª")
            confidence = signal_data.get("confidence", 0) * 100  # Convert to percentage

            message = (
                f"{emoji} *FOREX SIGNAL*\n\n"
                f"*Symbol:* {signal_data['symbol']}\n"
                f"*Signal:* {signal_data['signal']}\n"
                f"*Timeframe:* {signal_data['timeframe']}\n"
                f"*Confidence:* {confidence:.2f}%\n"
                f"*Time (UTC):* {signal_data['timestamp']}\n"
                f"*Market Regime:* {signal_data['market_regime']}\n"
                f"*Generated by:* {TradingConfig.AUTHOR} v{TradingConfig.VERSION}\n\n"
                f"_This is not financial advice_"
            )

            return message

        except Exception as e:
            logger.error(f"Error formatting signal message: {str(e)}")
            return "Error formatting signal message"

    @staticmethod
    def save_signal_history(signal_data: Dict) -> bool:
        """Save signal to historical record with proper metadata"""
        try:
            # Get the appropriate signal path
            signal_path = TradingConfig.get_signal_path(
                symbol=signal_data["symbol"],
                timeframe=signal_data["timeframe"],
                date=datetime.now(timezone.utc).strftime("%Y%m%d"),
            )

            # Load existing signals or create new list
            if signal_path.exists():
                signals = json.loads(signal_path.read_text())
            else:
                signals = []

            # Add metadata
            enriched_signal = {
                **signal_data,
                "saved_at": TradingConfig.get_current_timestamp(),
                "version": TradingConfig.VERSION,
                "author": TradingConfig.AUTHOR,
            }

            signals.append(enriched_signal)

            # Save updated signals
            signal_path.write_text(json.dumps(signals, indent=4))

            return True

        except Exception as e:
            logger.error(f"Error saving signal history: {str(e)}")
            return False

    @staticmethod
    def load_signal_history(symbol: str, timeframe: str, days: int = 7) -> List[Dict]:
        """Load historical signals for analysis"""
        try:
            signals: List[Dict] = []

            # Calculate date range
            end_date = datetime.now(timezone.utc)
            start_date = end_date - timedelta(days=days)

            # Iterate through date range
            current_date = start_date
            while current_date <= end_date:
                date_str = current_date.strftime("%Y%m%d")
                signal_path = TradingConfig.get_signal_path(symbol, timeframe, date_str)

                if signal_path.exists():
                    daily_signals = json.loads(signal_path.read_text())
                    signals.extend(daily_signals)

                current_date += timedelta(days=1)

            return signals

        except Exception as e:
            logger.error(f"Error loading signal history: {str(e)}")
            return []

    @staticmethod
    def calculate_signal_metrics(signals: List[Dict]) -> Dict:
        """Calculate comprehensive metrics from historical signals"""
        try:
            if not signals:
                return {}

            total_signals = len(signals)

            # Signal type distribution
            signal_types = {
                "BUY": len([s for s in signals if s["signal"] == "BUY"]),
                "SELL": len([s for s in signals if s["signal"] == "SELL"]),
                "HOLD": len([s for s in signals if s["signal"] == "HOLD"]),
            }

            # Calculate average confidence
            avg_confidence = (
                sum(s.get("confidence", 0) for s in signals) / total_signals
            )

            # Time-based analysis
            signals_with_time = []
            for signal in signals:
                try:
                    signal_time = datetime.strptime(
                        signal["timestamp"], "%Y-%m-%d %H:%M:%S"
                    )
                    signals_with_time.append({**signal, "datetime": signal_time})
                except (ValueError, KeyError):
                    continue

            # Sort by timestamp
            signals_with_time.sort(key=lambda x: x["datetime"])

            # Calculate time differences
            time_diffs = []
            for i in range(1, len(signals_with_time)):
                diff = (
                    signals_with_time[i]["datetime"]
                    - signals_with_time[i - 1]["datetime"]
                ).total_seconds() / 60
                time_diffs.append(diff)

            # Calculate time-based metrics
            avg_time_between = sum(time_diffs) / len(time_diffs) if time_diffs else 0
            days_span = (
                signals_with_time[-1]["datetime"] - signals_with_time[0]["datetime"]
            ).days + 1
            signals_per_day = total_signals / days_span if days_span > 0 else 0

            return {
                "total_signals": total_signals,
                "signal_distribution": signal_types,
                "average_confidence": avg_confidence,
                "average_time_between_signals": avg_time_between,
                "signals_per_day": signals_per_day,
                "days_analyzed": days_span,
                "first_signal": signals_with_time[0]["timestamp"],
                "last_signal": signals_with_time[-1]["timestamp"],
                "metadata": {
                    "calculated_at": TradingConfig.get_current_timestamp(),
                    "version": TradingConfig.VERSION,
                },
            }

        except Exception as e:
            logger.error(f"Error calculating signal metrics: {str(e)}")
            return {}

    @staticmethod
    def validate_signal_timing(
        symbol: str,
        timeframe: str,
        last_signals: List[Dict],
        min_interval: Optional[int] = None,
    ) -> bool:
        """Validate if enough time has passed since last signal"""
        try:
            if not last_signals:
                return True

            # Use configuration if not specified
            if min_interval is None:
                min_interval = TradingConfig.SIGNAL_PARAMS.min_signal_interval

            # Get latest signal for symbol/timeframe
            symbol_signals = [
                s
                for s in last_signals
                if s["symbol"] == symbol and s["timeframe"] == timeframe
            ]

            if not symbol_signals:
                return True

            latest_signal = max(
                symbol_signals,
                key=lambda x: datetime.strptime(x["timestamp"], "%Y-%m-%d %H:%M:%S"),
            )

            # Check time difference
            signal_time = datetime.strptime(
                latest_signal["timestamp"], "%Y-%m-%d %H:%M:%S"
            ).replace(tzinfo=timezone.utc)

            current_time = datetime.now(timezone.utc)
            time_diff = (current_time - signal_time).total_seconds() / 60

            return time_diff >= min_interval

        except Exception as e:
            logger.error(f"Error validating signal timing: {str(e)}")
            return False

    @staticmethod
    def generate_signal_report(
        symbol: str, timeframe: str, signals: List[Dict]
    ) -> Optional[str]:
        """Generate comprehensive signal performance report"""
        try:
            if not signals:
                logger.warning(f"No signals available for {symbol} {timeframe}")
                return None

            # Calculate metrics
            metrics = SignalUtils.calculate_signal_metrics(signals)

            # Create report directory
            report_dir = TradingConfig.REPORT_DIR / symbol / timeframe
            report_dir.mkdir(parents=True, exist_ok=True)

            # Generate report content
            report = (
                f"Signal Performance Report\n"
                f"========================\n"
                f"Symbol: {symbol}\n"
                f"Timeframe: {timeframe}\n"
                f"Period: {metrics['first_signal']} to {metrics['last_signal']}\n\n"
                f"Signal Statistics\n"
                f"-----------------\n"
                f"Total Signals: {metrics['total_signals']}\n"
                f"Days Analyzed: {metrics['days_analyzed']}\n"
                f"Signals per Day: {metrics['signals_per_day']:.2f}\n"
                f"Average Confidence: {metrics['average_confidence']:.2%}\n"
                f"Average Time Between Signals: {metrics['average_time_between_signals']:.1f} minutes\n\n"
                f"Signal Distribution\n"
                f"------------------\n"
                f"BUY Signals: {metrics['signal_distribution']['BUY']}\n"
                f"SELL Signals: {metrics['signal_distribution']['SELL']}\n"
                f"HOLD Signals: {metrics['signal_distribution']['HOLD']}\n\n"
                f"Generated by {TradingConfig.AUTHOR} v{TradingConfig.VERSION}\n"
                f"Report timestamp: {TradingConfig.get_current_timestamp()}\n"
            )

            # Save report
            report_file = (
                report_dir
                / f"signal_report_{symbol}_{timeframe}_{datetime.now(timezone.utc).strftime('%Y%m%d')}.txt"
            )
            report_file.write_text(report)

            return str(report_file)

        except Exception as e:
            logger.error(f"Error generating signal report: {str(e)}")
            return None
